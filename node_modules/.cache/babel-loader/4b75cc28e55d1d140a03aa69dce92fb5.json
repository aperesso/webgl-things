{"ast":null,"code":"import * as THREE from 'three';\nimport { loadTexture } from '../utils';\nimport Particle from './Particle';\nimport FlowField from './FlowField';\n\nclass ParticleSystem {\n  constructor() {\n    this.radius = 40;\n    this.particlesCount = 800;\n    this.mesh = null;\n    this.flowField = new FlowField(this.radius);\n    this.particles = null;\n  }\n\n}\n\nParticleSystem.prototype.initParticles = function () {\n  this.particles = new Array(this.particlesCount).fill(null).map(() => new Particle(this.radius));\n};\n\nParticleSystem.prototype.getPositionsAttribute = function () {\n  const positions = this.particles.reduce((acc, particle) => {\n    const x = particle.position.x;\n    const y = particle.position.y;\n    const z = particle.position.z;\n    return [...acc, x, y, z];\n  }, []);\n  return positions;\n};\n\nParticleSystem.prototype.initMesh = async function () {\n  const geometry = new THREE.BufferGeometry();\n  const positions = this.getPositionsAttribute();\n  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n  const texture = await loadTexture('particle.png');\n  const material = new THREE.PointsMaterial({\n    size: 0.3,\n    color: 0xffffff,\n    map: texture,\n    alphaMap: texture,\n    transparent: true,\n    opacity: 1.0,\n    depthWrite: false\n  });\n  this.mesh = new THREE.Points(geometry, material);\n};\n\nParticleSystem.prototype.init = async function () {\n  this.flowField.init();\n  this.initParticles();\n  await this.initMesh();\n};\n\nParticleSystem.prototype.animateParticles = function () {\n  this.particles.forEach(particle => {\n    const flow = this.flowField.getFlowDirection(particle.position);\n    particle.applyForce(flow);\n    particle.animate();\n  });\n};\n\nParticleSystem.prototype.updateMesh = function () {\n  const positions = this.getPositionsAttribute();\n  const vertices = this.mesh.geometry.attributes.position.array;\n\n  for (let i in vertices) {\n    vertices[i] = positions[i];\n  }\n\n  this.mesh.geometry.attributes.position.needsUpdate = true; // this.mesh.rotation.z += 0.01;\n};\n\nParticleSystem.prototype.animate = function () {\n  if (!this.particles || !this.mesh) return;\n  this.animateParticles(this.flowField);\n  this.updateMesh();\n};\n\nexport default ParticleSystem;","map":{"version":3,"sources":["/Users/alexiaperesson/webgl-things/src/classes/ParticleSystem.js"],"names":["THREE","loadTexture","Particle","FlowField","ParticleSystem","constructor","radius","particlesCount","mesh","flowField","particles","prototype","initParticles","Array","fill","map","getPositionsAttribute","positions","reduce","acc","particle","x","position","y","z","initMesh","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","texture","material","PointsMaterial","size","color","alphaMap","transparent","opacity","depthWrite","Points","init","animateParticles","forEach","flow","getFlowDirection","applyForce","animate","updateMesh","vertices","attributes","array","i","needsUpdate"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,WAAT,QAA4B,UAA5B;AAEA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,SAAP,MAAsB,aAAtB;;AAEA,MAAMC,cAAN,CAAqB;AACjBC,EAAAA,WAAW,GAAG;AACV,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,cAAL,GAAsB,GAAtB;AAEA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,SAAL,GAAiB,IAAIN,SAAJ,CAAc,KAAKG,MAAnB,CAAjB;AACA,SAAKI,SAAL,GAAiB,IAAjB;AACH;;AARgB;;AAWrBN,cAAc,CAACO,SAAf,CAAyBC,aAAzB,GAAyC,YAAW;AAChD,OAAKF,SAAL,GAAiB,IAAIG,KAAJ,CAAU,KAAKN,cAAf,EACZO,IADY,CACP,IADO,EAEZC,GAFY,CAER,MAAM,IAAIb,QAAJ,CAAa,KAAKI,MAAlB,CAFE,CAAjB;AAGH,CAJD;;AAMAF,cAAc,CAACO,SAAf,CAAyBK,qBAAzB,GAAiD,YAAW;AACxD,QAAMC,SAAS,GAAG,KAAKP,SAAL,CAAeQ,MAAf,CAAsB,CAACC,GAAD,EAAMC,QAAN,KAAmB;AACvD,UAAMC,CAAC,GAAGD,QAAQ,CAACE,QAAT,CAAkBD,CAA5B;AACA,UAAME,CAAC,GAAGH,QAAQ,CAACE,QAAT,CAAkBC,CAA5B;AACA,UAAMC,CAAC,GAAGJ,QAAQ,CAACE,QAAT,CAAkBE,CAA5B;AACA,WAAO,CAAC,GAAGL,GAAJ,EAASE,CAAT,EAAYE,CAAZ,EAAeC,CAAf,CAAP;AACH,GALiB,EAKf,EALe,CAAlB;AAMA,SAAOP,SAAP;AACH,CARD;;AAUAb,cAAc,CAACO,SAAf,CAAyBc,QAAzB,GAAoC,kBAAiB;AACjD,QAAMC,QAAQ,GAAG,IAAI1B,KAAK,CAAC2B,cAAV,EAAjB;AACA,QAAMV,SAAS,GAAG,KAAKD,qBAAL,EAAlB;AAEAU,EAAAA,QAAQ,CAACE,YAAT,CACI,UADJ,EAEI,IAAI5B,KAAK,CAAC6B,sBAAV,CAAiCZ,SAAjC,EAA4C,CAA5C,CAFJ;AAKA,QAAMa,OAAO,GAAG,MAAM7B,WAAW,CAAC,cAAD,CAAjC;AACA,QAAM8B,QAAQ,GAAG,IAAI/B,KAAK,CAACgC,cAAV,CAAyB;AACtCC,IAAAA,IAAI,EAAG,GAD+B;AAEtCC,IAAAA,KAAK,EAAE,QAF+B;AAGtCnB,IAAAA,GAAG,EAAEe,OAHiC;AAItCK,IAAAA,QAAQ,EAAEL,OAJ4B;AAKtCM,IAAAA,WAAW,EAAE,IALyB;AAMtCC,IAAAA,OAAO,EAAE,GAN6B;AAOtCC,IAAAA,UAAU,EAAE;AAP0B,GAAzB,CAAjB;AAUA,OAAK9B,IAAL,GAAY,IAAIR,KAAK,CAACuC,MAAV,CAAiBb,QAAjB,EAA2BK,QAA3B,CAAZ;AACH,CArBD;;AAuBA3B,cAAc,CAACO,SAAf,CAAyB6B,IAAzB,GAAgC,kBAAiB;AAC7C,OAAK/B,SAAL,CAAe+B,IAAf;AACA,OAAK5B,aAAL;AACA,QAAM,KAAKa,QAAL,EAAN;AACH,CAJD;;AAMArB,cAAc,CAACO,SAAf,CAAyB8B,gBAAzB,GAA4C,YAAW;AACnD,OAAK/B,SAAL,CAAegC,OAAf,CACItB,QAAQ,IAAI;AACR,UAAMuB,IAAI,GAAG,KAAKlC,SAAL,CAAemC,gBAAf,CAAgCxB,QAAQ,CAACE,QAAzC,CAAb;AACAF,IAAAA,QAAQ,CAACyB,UAAT,CAAoBF,IAApB;AACAvB,IAAAA,QAAQ,CAAC0B,OAAT;AACH,GALL;AAOH,CARD;;AAUA1C,cAAc,CAACO,SAAf,CAAyBoC,UAAzB,GAAsC,YAAW;AAC7C,QAAM9B,SAAS,GAAG,KAAKD,qBAAL,EAAlB;AACA,QAAMgC,QAAQ,GAAG,KAAKxC,IAAL,CAAUkB,QAAV,CAAmBuB,UAAnB,CAA8B3B,QAA9B,CAAuC4B,KAAxD;;AACA,OAAK,IAAIC,CAAT,IAAcH,QAAd,EAAwB;AACpBA,IAAAA,QAAQ,CAACG,CAAD,CAAR,GAAclC,SAAS,CAACkC,CAAD,CAAvB;AACH;;AACD,OAAK3C,IAAL,CAAUkB,QAAV,CAAmBuB,UAAnB,CAA8B3B,QAA9B,CAAuC8B,WAAvC,GAAqD,IAArD,CAN6C,CAO7C;AACH,CARD;;AAYAhD,cAAc,CAACO,SAAf,CAAyBmC,OAAzB,GAAmC,YAAW;AAC1C,MAAI,CAAC,KAAKpC,SAAN,IAAmB,CAAC,KAAKF,IAA7B,EAAmC;AACnC,OAAKiC,gBAAL,CAAsB,KAAKhC,SAA3B;AACA,OAAKsC,UAAL;AACH,CAJD;;AAMA,eAAe3C,cAAf","sourcesContent":["import * as THREE from 'three';\n\nimport { loadTexture } from '../utils';\n\nimport Particle from './Particle';\nimport FlowField from './FlowField'\n\nclass ParticleSystem {\n    constructor() {\n        this.radius = 40;\n        this.particlesCount = 800;\n\n        this.mesh = null;\n        this.flowField = new FlowField(this.radius);\n        this.particles = null;\n    }\n}\n\nParticleSystem.prototype.initParticles = function() {\n    this.particles = new Array(this.particlesCount)\n        .fill(null)\n        .map(() => new Particle(this.radius))\n}\n\nParticleSystem.prototype.getPositionsAttribute = function() {\n    const positions = this.particles.reduce((acc, particle) => {\n        const x = particle.position.x;\n        const y = particle.position.y;\n        const z = particle.position.z;\n        return [...acc, x, y, z]\n    }, [])\n    return positions;\n}\n\nParticleSystem.prototype.initMesh = async function() {\n    const geometry = new THREE.BufferGeometry();\n    const positions = this.getPositionsAttribute();\n    \n    geometry.setAttribute(\n        'position',\n        new THREE.Float32BufferAttribute(positions, 3)\n    )\n\n    const texture = await loadTexture('particle.png');\n    const material = new THREE.PointsMaterial({\n        size : 0.3,\n        color: 0xffffff,\n        map: texture,\n        alphaMap: texture,\n        transparent: true,\n        opacity: 1.0,\n        depthWrite: false\n    });\n\n    this.mesh = new THREE.Points(geometry, material);\n}\n\nParticleSystem.prototype.init = async function() {\n    this.flowField.init();\n    this.initParticles();\n    await this.initMesh();\n}\n\nParticleSystem.prototype.animateParticles = function() {\n    this.particles.forEach(\n        particle => {\n            const flow = this.flowField.getFlowDirection(particle.position);\n            particle.applyForce(flow)\n            particle.animate()\n        }\n    );\n}\n\nParticleSystem.prototype.updateMesh = function() {\n    const positions = this.getPositionsAttribute();\n    const vertices = this.mesh.geometry.attributes.position.array;\n    for (let i in vertices) {\n        vertices[i] = positions[i]\n    }\n    this.mesh.geometry.attributes.position.needsUpdate = true;\n    // this.mesh.rotation.z += 0.01;\n}\n\n\n\nParticleSystem.prototype.animate = function() {\n    if (!this.particles || !this.mesh) return;\n    this.animateParticles(this.flowField)\n    this.updateMesh();\n}\n\nexport default ParticleSystem"]},"metadata":{},"sourceType":"module"}