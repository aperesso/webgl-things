{"ast":null,"code":"import * as THREE from 'three';\n\nconst loadFile = path => {\n  const file = new Promise((resolve, reject) => {\n    fetch(path).then(res => res.text()).then(data => resolve(data));\n  });\n  return file;\n};\n\nconst loadShaders = async shaderName => {\n  const shaders = await Promise.all(['fragmentShader', 'vertexShader'].map(shaderType => loadFile(\"\".concat(process.env.PUBLIC_URL, \"/shaders/\").concat(shaderName, \"/\").concat(shaderType, \".glsl\"))));\n  return {\n    fragmentShader: shaders[0],\n    vertexShader: shaders[1]\n  };\n};\n\nconst loadTexture = async file => {\n  const loader = new THREE.TextureLoader();\n  const texture = await new Promise((resolve, reject) => {\n    loader.load(\"\".concat(process.env.PUBLIC_URL, \"/assets/\").concat(file), texture => {\n      resolve(texture);\n    });\n  });\n  return texture;\n};\n\nconst loadFont = file => {\n  const loader = new THREE.FontLoader();\n  const font = new Promise(resolve => {\n    loader.load(\"\".concat(process.env.PUBLIC_URL, \"/assets/fonts/\").concat(file, \".typeface.json\"), font => resolve(font));\n  });\n  return font;\n};\n\nconst colorToShader = color => {\n  return new THREE.Vector3(...color.map(color => color / 255.0));\n};\n\nconst loadAudio = file => {\n  const loader = new THREE.AudioLoader();\n  const audio = new Promise(resolve => {\n    loader.load(\"\".concat(process.env.PUBLIC_URL, \"/assets/sound/\").concat(file), buffer => {\n      resolve(buffer);\n    });\n  });\n  return audio;\n};\n\nexport { loadFile, loadShaders, loadFont, colorToShader, loadTexture, loadAudio };","map":{"version":3,"sources":["/Users/alexiaperesson/webgl-things/src/utils/index.js"],"names":["THREE","loadFile","path","file","Promise","resolve","reject","fetch","then","res","text","data","loadShaders","shaderName","shaders","all","map","shaderType","process","env","PUBLIC_URL","fragmentShader","vertexShader","loadTexture","loader","TextureLoader","texture","load","loadFont","FontLoader","font","colorToShader","color","Vector3","loadAudio","AudioLoader","audio","buffer"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;;AAEA,MAAMC,QAAQ,GAAGC,IAAI,IAAI;AAErB,QAAMC,IAAI,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC1CC,IAAAA,KAAK,CAACL,IAAD,CAAL,CACKM,IADL,CACUC,GAAG,IAAIA,GAAG,CAACC,IAAJ,EADjB,EAEKF,IAFL,CAEUG,IAAI,IAAIN,OAAO,CAACM,IAAD,CAFzB;AAGH,GAJY,CAAb;AAMA,SAAOR,IAAP;AACH,CATD;;AAWA,MAAMS,WAAW,GAAG,MAAMC,UAAN,IAAoB;AAEpC,QAAMC,OAAO,GAAG,MAAMV,OAAO,CAACW,GAAR,CAAY,CAAC,gBAAD,EAAmB,cAAnB,EAC7BC,GAD6B,CACzBC,UAAU,IAAIhB,QAAQ,WACpBiB,OAAO,CAACC,GAAR,CAAYC,UADQ,sBACcP,UADd,cAC4BI,UAD5B,WADG,CAAZ,CAAtB;AAMA,SAAO;AACHI,IAAAA,cAAc,EAAGP,OAAO,CAAC,CAAD,CADrB;AAEHQ,IAAAA,YAAY,EAAGR,OAAO,CAAC,CAAD;AAFnB,GAAP;AAIH,CAZD;;AAcA,MAAMS,WAAW,GAAG,MAAMpB,IAAN,IAAc;AAC9B,QAAMqB,MAAM,GAAG,IAAIxB,KAAK,CAACyB,aAAV,EAAf;AACA,QAAMC,OAAO,GAAG,MAAM,IAAItB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACnDkB,IAAAA,MAAM,CAACG,IAAP,WAAeT,OAAO,CAACC,GAAR,CAAYC,UAA3B,qBAAgDjB,IAAhD,GAAwDuB,OAAO,IAAI;AAC/DrB,MAAAA,OAAO,CAACqB,OAAD,CAAP;AACH,KAFD;AAGH,GAJqB,CAAtB;AAKA,SAAOA,OAAP;AACH,CARD;;AAUA,MAAME,QAAQ,GAAGzB,IAAI,IAAI;AACrB,QAAMqB,MAAM,GAAG,IAAIxB,KAAK,CAAC6B,UAAV,EAAf;AAEA,QAAMC,IAAI,GAAG,IAAI1B,OAAJ,CAAYC,OAAO,IAAI;AAChCmB,IAAAA,MAAM,CAACG,IAAP,WAAeT,OAAO,CAACC,GAAR,CAAYC,UAA3B,2BAAsDjB,IAAtD,qBAA4E2B,IAAI,IAAIzB,OAAO,CAACyB,IAAD,CAA3F;AACH,GAFY,CAAb;AAIA,SAAOA,IAAP;AACH,CARD;;AAUA,MAAMC,aAAa,GAAGC,KAAK,IAAI;AAC3B,SAAO,IAAIhC,KAAK,CAACiC,OAAV,CAAkB,GAAGD,KAAK,CAAChB,GAAN,CAAUgB,KAAK,IAAIA,KAAK,GAAG,KAA3B,CAArB,CAAP;AACH,CAFD;;AAIA,MAAME,SAAS,GAAG/B,IAAI,IAAI;AACtB,QAAMqB,MAAM,GAAG,IAAIxB,KAAK,CAACmC,WAAV,EAAf;AAEA,QAAMC,KAAK,GAAG,IAAIhC,OAAJ,CAAYC,OAAO,IAAI;AACjCmB,IAAAA,MAAM,CAACG,IAAP,WAAeT,OAAO,CAACC,GAAR,CAAYC,UAA3B,2BAAsDjB,IAAtD,GAA8DkC,MAAM,IAAI;AACpEhC,MAAAA,OAAO,CAACgC,MAAD,CAAP;AACH,KAFD;AAGH,GAJa,CAAd;AAMA,SAAOD,KAAP;AACH,CAVD;;AAYA,SACInC,QADJ,EAEIW,WAFJ,EAGIgB,QAHJ,EAIIG,aAJJ,EAKIR,WALJ,EAMIW,SANJ","sourcesContent":["import * as THREE from 'three';\n\nconst loadFile = path => {\n\n    const file = new Promise((resolve, reject) => {\n        fetch(path)\n            .then(res => res.text())\n            .then(data => resolve(data))\n    })\n\n    return file;\n}\n\nconst loadShaders = async shaderName => {\n\n    const shaders = await Promise.all(['fragmentShader', 'vertexShader']\n        .map(shaderType => loadFile(\n            `${process.env.PUBLIC_URL}/shaders/${shaderName}/${shaderType}.glsl`\n        ))\n    )\n\n    return {\n        fragmentShader : shaders[0],\n        vertexShader : shaders[1]\n    } \n}\n\nconst loadTexture = async file => {\n    const loader = new THREE.TextureLoader();\n    const texture = await new Promise((resolve, reject) => {\n        loader.load(`${process.env.PUBLIC_URL}/assets/${file}`, texture => {\n            resolve(texture)\n        })\n    })\n    return texture;\n}\n\nconst loadFont = file => {\n    const loader = new THREE.FontLoader();\n\n    const font = new Promise(resolve => {\n        loader.load(`${process.env.PUBLIC_URL}/assets/fonts/${file}.typeface.json`, font => resolve(font));\n    })\n\n    return font;\n}\n\nconst colorToShader = color => {\n    return new THREE.Vector3(...color.map(color => color / 255.0))\n}\n\nconst loadAudio = file => {\n    const loader = new THREE.AudioLoader();\n\n    const audio = new Promise(resolve => {\n        loader.load(`${process.env.PUBLIC_URL}/assets/sound/${file}`, buffer => {\n            resolve(buffer)\n        })\n    })\n\n    return audio;\n}\n\nexport {\n    loadFile,\n    loadShaders,\n    loadFont,\n    colorToShader,\n    loadTexture,\n    loadAudio\n}"]},"metadata":{},"sourceType":"module"}